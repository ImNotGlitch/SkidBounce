/*
 * SkidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge, Forked from LiquidBounce.
 * https://github.com/ManInMyVan/SkidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.MotionEvent
import net.ccbluex.liquidbounce.event.MoveEvent
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablermodes.DisablerMode
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablermodes.other.*
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablermodes.vulcan.*
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.Value

object Disabler : Module("Disabler", ModuleCategory.EXPLOIT) {
    private val debug = BoolValue("Debug", false)
    var settings: List<Value<*>> = arrayListOf(debug)
    private val modes = arrayOf(
        VulcanOmniSprint,
        NoTransaction,
        NoKeepAlive,
        NoSwing,
        NoEntityAction,
        NoAbilities,
        NoDigging,
        Riding,
        NoFlying,
        VulcanAutoBlock,
        GrimFastBreak,
    ).sortedBy { it.modeName }
        .onEach { mode ->
            settings += object : BoolValue(mode.modeName, false) {
                override fun onChange(oldValue: Boolean, newValue: Boolean): Boolean {
                    if (state && newValue && !oldValue) mode.onEnable()
                    if (state && !newValue && oldValue) mode.onDisable()
                    return newValue
                }
            }
            mode.settings.onEach {
                settings += it
            }
        }

    override fun onEnable() { getActiveModes().onEach { it.onEnable() } }
    override fun onDisable() { getActiveModes().onEach { it.onDisable() } }

    @EventTarget(priority = 2)
    fun onPacket(event: PacketEvent) {
        if (event.isCancelled) return
        getActiveModes().onEach { it.onPacket(event) }
    }
    @EventTarget
    fun onUpdate() { getActiveModes().onEach { it.onUpdate() } }
    @EventTarget
    fun onMove(event: MoveEvent) { getActiveModes().onEach { it.onMove(event) } }
    @EventTarget
    fun onMotion(event: MotionEvent) { getActiveModes().onEach { it.onMotion(event) } }

    private fun getActiveModes(): List<DisablerMode> {
        val active: MutableList<DisablerMode> = mutableListOf()
        modes.onEach { mode -> values.forEach { value ->
            if (mode.modeName == value.name && value.get() as Boolean)
                active += mode
        }}
        return active
    }

    fun isEnabled(mode: DisablerMode): Boolean {
        return getActiveModes().contains(mode)
    }

    override val values: List<Value<*>>
        get() = settings

    fun debug(message: String) {
        if (debug.get())
            ClientUtils.displayChatMessage("§7[§cDebug§7]§r $message")
    }
}
