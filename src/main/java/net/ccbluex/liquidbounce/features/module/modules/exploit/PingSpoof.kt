/*
 * SkidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge, Forked from LiquidBounce.
 * https://github.com/ManInMyVan/SkidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.GameLoopEvent
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.WorldEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory.EXPLOIT
import net.ccbluex.liquidbounce.features.module.modules.combat.Velocity
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.IntegerValue
import net.minecraft.network.Packet
import net.minecraft.network.play.server.*

object PingSpoof : Module("PingSpoof", EXPLOIT) {

    private val pingOnly by BoolValue("PingOnly", false)

    private val spoofDelay by IntegerValue("SpoofDelay", 500, 0..25000)

    private val packetQueue = LinkedHashMap<Packet<*>, Long>()

    override fun onDisable() = reset()

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet

        if (event.isCancelled || mc.thePlayer == null)
            return

        if (pingOnly) {
            if (packet is S32PacketConfirmTransaction || packet is S00PacketKeepAlive) {
                event.cancelEvent()

                // Use nano time for the registration time since there are chances
                // the packets can be under the same milliseconds and mess up the order
                synchronized(packetQueue) {
                    packetQueue[packet] = System.currentTimeMillis()
                }
            }
        } else {
            // This should bypass simulation AntiCheat better.
            // Example: Grim (Still Flag for Reach due to S32PacketConfirmTransaction)
            if (packet is S32PacketConfirmTransaction || packet is S00PacketKeepAlive ||
                packet is S39PacketPlayerAbilities || packet is S19PacketEntityStatus ||
                (packet is S12PacketEntityVelocity && !Velocity.delayMode) ||  packet is S08PacketPlayerPosLook
            ) {
                event.cancelEvent()

                // Use nano time for the registration time since there are chances
                // the packets can be under the same milliseconds and mess up the order
                synchronized(packetQueue) {
                    packetQueue[packet] = System.currentTimeMillis()
                }
            }
        }
    }

    @EventTarget
    fun onGameLoop(event: GameLoopEvent) = sendPacketsByOrder(false)

    @EventTarget
    fun onWorld(event: WorldEvent) = packetQueue.clear()

    // Accept packets that have passed the requested delay, then sort by registration time
    private fun sendPacketsByOrder(all: Boolean) =
        synchronized(packetQueue) {
            packetQueue.entries.removeAll { (packet, timestamp) ->
                if (all || timestamp <= (System.currentTimeMillis() - spoofDelay)) {
                    PacketUtils.queuedPackets.add(packet)
                    true
                } else false
            }
        }

    private fun reset() {
        sendPacketsByOrder(true)

        packetQueue.clear()
    }
}
